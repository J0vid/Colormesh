




```{r}

devtools::install_github("j0vid/Colormesh", build_vignettes = F)
## Changed build_vignettes = F to build_vignettes = F, was then able to download the package. Sent David an email

library(Colormesh)


```

```{r}

## Prompts for the user to identify where the folder containing their images that have been unwarped to a consensus shape are located (user provides file path)
## Prompt to load the TPS file of the consensus shape

## Prompt, will you be using colormesh to standard your measured color using landmarks placed on a color standard?
## Prompt to identify the file path for the location of the original images that contain the color standard
## Prompt asking for known RGB values for each color in the color standard - what format? Have them upload a csv with the information? Order of known color standard values will need to be in the same order as the landmarks appear
## Prompt to load the TPS file containing the coordinates of the LM placed on the color standard

## Read in your factor file to identify images. The first column must contain the image file name (omit the file type extension). These files should not contain headers. The user will be able to identify column headers when they read in the csv.


## How about a factors list function, factor.names = (file.name.csv, column 1 name, col 2 name, col 3 name)
## So this function will identify what column the image name is in, as well as provide any number of ID factors the person will need to separate out data based on that factor - established what the factor names are in the process



################# original images in first column, unwarped in second column (so we can make sure images are in the same order) 
specimen.factors = read.csv("C:/Users/jennv/Desktop/CM_test/cm_test_factors.csv", header = F)



##Read in the TPS file containing the landmark coordinates for the consensus shape
## Make a function that will employ the read.tps function
## For example. lm.coords = <file name of the TPS file, can combo in the next line of code

LM_coords = read.tps(data= "C:/Users/jennv/Desktop/CM_test/CM_test_consensus_coords.TPS")



## For David, this creates a 3rd, 4th, 5th, column that don't make sense...? I think it's because the data being pulled is when you perform the unwarping within R. Maybe have a prompt that asks whether you're providing a consensus shape that was processed using the TPS series software...? Then, the user would want to make sure that the order of the unwarped images are in the same order as they appear in the factors list.

## This will strip columns 3-5 since they're nonsense at this point
LM_coords2 = as.matrix(cbind(LM_coords[,1], LM_coords[,2]))


################ Update the read.tps function so it will adjust the image dimensions
################  add color standardization read in of landmark coords here



```

```{r}

## Pointmap to define an order of points to include during the triangulation process


point.map = c(1,8:17,2, 18:19,3,20:27,4, 28:42,5,43:52,6,53:54,7,55:62)

```

```{r}

## My fresh R session needed me to load tripack and sp
## Is there a way to make colormesh call for these packages to be loaded at the very beginning?

##A way to clean up the user input so it's more like: tri.surf(consensus_coords, point.map, rounds_of_triangulation)

specimen.template = tri.surf(LM_coords2[point.map,], 2)
## Above identifies the sampling points coordinates that resulted from the triangulation

```

```{r}

##Next park is sampling radius, I have no idea what function to use to set the radius size

###### Set something up for the bibtex to that if someone uses it, it will provide how to cite the package

image.circ = sampling.circle(2)


```

```{r}

############################## This needs to be a function  call it rgb.measure
############################## needs image file loc, image name, LM coords from DT, sampling.circle

PRLP17.gup.r = matrix(0, ncol=length(gupbody.PRLP17.template[,1]), nrow = length(gup.PRLP17.factors[,1]))
PRLP17.gup.g = matrix(0, ncol=length(gupbody.PRLP17.template[,1]), nrow = length(gup.PRLP17.factors[,1]))
PRLP17.gup.b = matrix(0, ncol=length(gupbody.PRLP17.template[,1]), nrow = length(gup.PRLP17.factors[,1]))

input_PRLP17_gup = dir("C:/Users/jennv/OneDrive - Florida State University/Guppy Color Analysis/Crop/PRLP17_unwarped/", pattern= glob2rx("*.TIF"))

for(ind in 1:length(gup.PRLP17.factors[,1])){

  read_imagegup_PRLP17= c("C:/Users/jennv/OneDrive - Florida State University/Guppy Color Analysis/Crop/PRLP17_unwarped/",input_PRLP17_gup[ind])

  PRLP17_tempimage= readImage(paste(read_imagegup_PRLP17, collapse= "")) 
  PRLP17_tempimage2 = array(0,dim = c(dim(PRLP17_tempimage)[1]+ 2*px.radius,dim(PRLP17_tempimage)[2]+ 2*px.radius, 3))
  PRLP17_tempimage2[px.radius:(dim(PRLP17_tempimage)[1]),(px.radius):(dim(PRLP17_tempimage)[2]),] = PRLP17_tempimage[,,]

  for(i in 1:length(gupbody.PRLP17.template[,1])){

    PRLP17.gup.r[ind,i] =  PRLP17_tempimage2[(gupbody.PRLP17.template[i,1]), px.radius +(gupbody.PRLP17.template[i,2]), 1]

    PRLP17.gup.g[ind,i] =  PRLP17_tempimage2[(gupbody.PRLP17.template[i,1]), px.radius +(gupbody.PRLP17.template[i,2]), 2]

    PRLP17.gup.b[ind,i] =  PRLP17_tempimage2[(gupbody.PRLP17.template[i,1]), px.radius +(gupbody.PRLP17.template[i,2]), 3]

    if(i %% 50 == 0) {print(paste0(round((i/length(gupbody.PRLP17.template[,1]))*100, digits = 0), "% ", "done with image ", ind, " out of ", length(gup.PRLP17.factors[,1])))}

  }

}

```



```{r}

############################## THIS WILL BE COME ONE FUNCTION TO DO ALL THE DIRTY WORK OF READING IN KNOWN VALUES, SAMPLING COLOR STANDARD< CALC DEVIATION, AND APPLYING CORRECTION

PRLP17_calibfile = read.tps("C:/Users/jennv/OneDrive - Florida State University/Guppy Color Analysis/PRLP17 CALIB.TPS")
PRLP17_calib.coords = as.matrix(cbind(PRLP17_calibfile[,1],2912-PRLP17_calibfile[,2]))



```


Input of the known RGB values of the 5 colors on the standard. Each value is divided by 255 because the values in R are on a scale from 0 to 1.
```{r}
###################### known.vals = read.csv(<file_name.csv>)
###################### csv should have columns be the color standard color, rows be red, green, blue)

napth_crim.r=173/255
cad_orange.r=243/255
cad_yel.r=254/255
em_green.r=43/255
iv_black.r=26/255

napth_crim.g=43/255
cad_orange.g=121/255
cad_yel.g=244/255
em_green.g=163/255
iv_black.g=13/255

napth_crim.b=50/255
cad_orange.b=33/255
cad_yel.b=17/255
em_green.b=73/255
iv_black.b=21/255

```

```{r}
PRLP17_calibfile = read.tps("C:/Users/jennv/OneDrive - Florida State University/Guppy Color Analysis/PRLP17 CALIB.TPS")
PRLP17_calib.coords = as.matrix(cbind(PRLP17_calibfile[,1],2912-PRLP17_calibfile[,2]))



```


Input of the known RGB values of the 5 colors on the standard. Each value is divided by 255 because the values in R are on a scale from 0 to 1.
```{r}
napth_crim.r=173/255
cad_orange.r=243/255
cad_yel.r=254/255
em_green.r=43/255
iv_black.r=26/255

napth_crim.g=43/255
cad_orange.g=121/255
cad_yel.g=244/255
em_green.g=163/255
iv_black.g=13/255

napth_crim.b=50/255
cad_orange.b=33/255
cad_yel.b=17/255
em_green.b=73/255
iv_black.b=21/255

```



The following code creates a matrix that will contain the RGB values that has individual fish ID's for each row and number of landmarks are the columns. There are only 5 since each image has 5 landmarks placed on the color standard. Since the tps file has five lines of X & Y coords per fish, the seq function will apply only the 5 lines of X and Y coords at a time, thus separating each fish out from the tps file. If there are errors when running this chunk of code, check that the input_gup_cal is actually finding your .tif files. If it isn't locating them, change between capitalized or lowercase TIF until it recognizes the file suffix.
```{r}
px.radius = 2
circle.coords=sampling.circle(px.radius)

PRLP17.r_cal = matrix(0,nrow = length(gup.PRLP17.factors[,1]), ncol=5)
PRLP17.g_cal = matrix(0,nrow = length(gup.PRLP17.factors[,1]), ncol=5)
PRLP17.b_cal = matrix(0,nrow = length(gup.PRLP17.factors[,1]), ncol=5)

input_PRLP17_cal = dir("C:/Users/jennv/OneDrive - Florida State University/Guppy Color Analysis/PRLP17 calib pics/", pattern= glob2rx("*.TIF"))

a <- seq(1,length(PRLP17_calibfile[,1]), 5)

for(ind in 1: length(a)){
   
  read_imagePRLP17_cal= c("C:/Users/jennv/OneDrive - Florida State University/Guppy Color Analysis/PRLP17 calib pics/", input_PRLP17_cal[ind])
  PRLP17tempimage_cal= readImage(paste(read_imagePRLP17_cal, collapse= "")) 
  PRLP17tempimage2_cal = array(0,dim = c(dim(PRLP17tempimage_cal)[1]+ 2*px.radius,dim(PRLP17tempimage_cal)[2]+ 2*px.radius, 3))
  PRLP17tempimage2_cal[(px.radius):(dim(PRLP17tempimage_cal)[1]+(px.radius-1)),(px.radius+1):(dim(PRLP17tempimage_cal)[2]+(px.radius)),] = PRLP17tempimage_cal[,,]
  for(i in 1:5){
    PRLP17.r_cal[ind,i] =  mean(diag(PRLP17tempimage2_cal[(PRLP17_calib.coords[a[ind] - 1 + i,1]+circle.coords[,1]), px.radius +(PRLP17_calib.coords[a[ind] - 1 + i,2]+circle.coords[,2]), 1]))
    PRLP17.g_cal[ind,i] =  mean(diag(PRLP17tempimage2_cal[(PRLP17_calib.coords[a[ind] - 1 + i,1]+circle.coords[,1]), px.radius +(PRLP17_calib.coords[a[ind] - 1 + i,2]+circle.coords[,2]), 2]))
    PRLP17.b_cal[ind,i] =  mean(diag(PRLP17tempimage2_cal[(PRLP17_calib.coords[a[ind] - 1 + i,1]+circle.coords[,1]), px.radius +(PRLP17_calib.coords[a[ind] - 1 + i,2]+circle.coords[,2]), 3]))
    if(i %% 50 == 0) {print(paste0(round((i/length(PRLP17_calib.coords[,1]))*100, digits = 0), "% ", "done with image ", ind, " out of ", length(gup.PRLP17.factors)))}
  }
}



```



The following code creates the vectors of the known RGB values for each of the colors on the standard.
```{r}

PRLP17_calib_red=cbind(napth_crim.r, cad_orange.r,cad_yel.r,em_green.r,iv_black.r)
PRLP17_calib_green=cbind(napth_crim.g,cad_orange.g, cad_yel.g,em_green.g, iv_black.g)
PRLP17_calib_blue=cbind(napth_crim.b,cad_orange.b,cad_yel.b,em_green.b, iv_black.b)

```


This is where a matrix is created of the deviation of each individual landmark from the known values for RGB by subtractin the known RGB values from the measured RGB values. 
```{r}
PRLP17_red_dev=rep(0,length(gup.PRLP17.factors[,1]))
for(i in 1:length(gup.PRLP17.factors[,1])){
  PRLP17_red_dev[i]=mean(PRLP17.r_cal[i,]-PRLP17_calib_red)
}

PRLP17_green_dev=rep(0,length(gup.PRLP17.factors[,1]))
for(i in 1:length(gup.PRLP17.factors[,1])){
  PRLP17_green_dev[i]=mean(PRLP17.g_cal[i,]-PRLP17_calib_green)
}

PRLP17_blue_dev=rep(0,length(gup.PRLP17.factors[,1]))
for(i in 1:length(gup.PRLP17.factors[,1])){
  PRLP17_blue_dev[i]=mean(PRLP17.b_cal[i,]-PRLP17_calib_blue)
}


```

############### Create a before and after plotting function to show original image (based on original measurements collected from DT collection of data, vs the image plot showing the values after the calibration correction was applied. So there is a side by side comparison)




################ Streamline this for the package

```{r, fig.width=10,fig.height=6, dpi=400}
ind = 4  ##This will plot what your second image looks like

plot(gupbody.PRLP17.template[,1], -gupbody.PRLP17.template[,2], main="PRLP17 4DT 0pix individual is EXPPRLP17BMC2", asp=1)
    text(1400,0, ind)
    for(i in 1: length(gupbody.PRLP17.template[,1])){
      points(gupbody.PRLP17.template[i,1], -gupbody.PRLP17.template[i,2], col= rgb(PRLP17.r_cor[ind,i],PRLP17.g_cor[ind,i],PRLP17.b_cor[ind,i]), pch=19, cex=1.2)}
    
    
  
```
